1. Testing plots
A data-science course without visualizations

2. Pizza without cheese!
is like a pizza without cheese.

3. This lesson: testing matplotlib visualizations
Therefore, in this lesson, we will add some cheese by testing visualizations generated by the plotting library matplotlib.

4. The plotting function
We have a Python package called visualization under the application directory src.

5. The plotting function
The package has a Python module called plots.py. The module contains a function called get_plot_for_best_fit_line(), which we are going to test. It takes the slope and the intercept of the best fit line as arguments.

6. The plotting function
Other arguments include x_array and y_array, which hold the housing area and prices data respectively, either from the training set or the testing set.

7. The plotting function
The final argument is the plot's title.

8. The plotting function
The function returns a matplotlib figure.

9. Training plot
After we have obtained the best fit line on the training set using the train_model() function, we will call the plotting function, as shown here. This produces the training plot.

10. Testing plot
We can also plot the best fit line on the testing set. This produces the testing plot.

11. Don't test properties individually
The return value of the plotting function is a matplotlib.figure.Figure() object. This object has tons of properties, for example, the axes and its configuration and style, the plotted data and its style, annotations and its style etc. Due to the sheer number of properties, it is not advisable to test each of them individually.

12. Testing strategy for plots
Instead, we will use a shortcut using the human eye.

13. Testing strategy for plots
The idea involves two steps - a one-time baseline generation and testing.

14. One-time baseline generation
To generate the one-time baseline, we decide on a set of test arguments for the plotting function.

15. One-time baseline generation
Then we call the plotting function with these test arguments

16. One-time baseline generation
and convert the returned matplotlib.figure.Figure() object into a PNG image.

17. One-time baseline generation
We inspect this image manually

18. One-time baseline generation
and verify that it looks as expected. If it does, we store this image as a baseline image.

19. One-time baseline generation
If it doesn't, we modify the function until it does.

20. Testing
The testing step involves generating a PNG image for the test arguments that we decided upon earlier

21. Testing
and comparing the image with the stored baseline image.

22. pytest-mpl
Since images generated on different operating systems look slightly different, we need to use a pytest plugin called pytest-mpl for image comparisons. This library knows how to ignore the operating system related differences and makes it easy to generate baseline images. We install it using pip.

23. An example test
To illustrate how this package works, we will write a test called test_plot_for_linear_data(). For this test, we have decided on a simple linear data set. Instead of an assert statement, the test returns the matplotlib figure returned by the function under test.

24. An example test
That's because we will use a marker called pytest.mark.mpl_image_compare, and this will do the image comparison and the baseline image generation under the hood.

25. Generating the baseline image
pytest expects baseline images to be stored in a folder called baseline relative to the test module test_plots.py. To generate the baseline image, we run the test with the command line argument --mpl-generate-path and enter the path to the baseline folder as argument. This will create the baseline image.

26. Verify the baseline image
Then we open the baseline image and confirm that it looks as expected.

27. Run the test
The next time we run the test, we must use the --mpl option with the pytest command. This will make pytest compare the baseline image with the actual one. If they are identical, then the test will pass.

28. Reading failure reports
If they are not identical, the test will fail and pytest will save the baseline image, the actual image and an image containing the pixelwise difference to a temporary directory. The paths to these images will be printed in the failures section of the test result report, as we see here. Looking at these images helps in debugging the function.