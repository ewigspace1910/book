1. Indexes
When it comes to query performance tuning, adding an index to a table can be a game changer. In this lesson we'll examine a brief overview of indexes and how they can be used to improve query performance.

2. What is an index?
An index is a structure added to a table to improve the speed of accessing data. Indexes are used to locate data quickly without having to scan or search every row in a table, this makes them particularly useful for improving performance of queries with filter conditions. Indexes are applied to table columns and they can be added at any time. Adding an index to a table is typically done by the database administrator. SQL Server supports several different index types. The two most common table indexes are Clustered and Nonclustered.

3. Clustered and nonclustered indexes
A good analogy for a clustered index is a dictionary where words are stored alphabetically. With a clustered index the data, in the data pages, are stored and ordered by the column(s) with the index. Because the data is ordered one way, a table can only have one clustered index. Clustered indexes reduce the number of data page reads by a query which helps speed up search operations.

4. Clustered and nonclustered indexes
For a nonclustered index a good analogy is a text book with an index at the back. Data in the book is unordered and the index at the back indicates the page numbers containing a search condition. Like a text book a table with a nonclustered index allows data to be unordered in the table data pages. Another layer in the index structure contains ordered pointers to the data pages. A table can contain more than one nonclustered index. Nonclustered indexes are commonly used to improve table insert and update operations.

5. Clustered index: B-tree structure
Let's take a look at how a clustered index can improve performance. A clustered index creates what is called a B-tree structure on a table. We can think of a B-tree as an upside tree where the trunk is called the root node, branches the branch nodes, and leaves the page nodes.

6. Clustered index: B-tree structure
The root node contains ordered pointers to branch nodes which in turn contain ordered pointers to page nodes. The page node level contains all the 8 kilobyte data pages from the table with the data physically ordered by the column(s) with the clustered index. Without a clustered index, there is no guarantee the data is ordered in the table data pages.

7. Customers table without clustered index
Using our Customers table as an example, if we queried for all rows where CustomerID is equal to PARIS, without an index, all pages in the table would be scanned for a match.

8. Customers table without clustered index
9. Customers table without clustered index
10. Customers table without clustered index
11. Customers table with clustered index
If our Customers table has a clustered index on CustomerID, then the search would enter the B-tree at pointers nearest to our match,

12. Customers table with clustered index
in this case, between OLDWO and WOLZA.

13. Customers table with clustered index
The ordered pointers at each branch node would in turn direct the search to the

14. Customers table with clustered index
page, or pages,

15. Customers table with clustered index
containing the CustomerID we’re searching for.

16. Clustered index: example
Let’s look at this in action. We’ll query the PlayerStats table for all rows where the Team is Oklahoma City, team code OKC. We’ll turn on STATISTICS IO so we can determine the number of page reads used by our query. Without an index the whole table is scanned for rows that meet the filter condition, logical reads indicate twelve pages read. When we add a clustered index to the Team column, the number of page reads drops to two. In general, the fewer pages read to complete the query, the faster it will run.
----------------
1. Execution plans
In this final lesson, we’ll introduce SQL Execution Plans and some basic examples of what they can tell us.

2. Optimization phase
When a query is submitted to a database engine, after passing all the syntax, table, and data checks, it is passed to an Optimization Phase,

3. Optimization phase
which evaluates several execution plans to determine which one will return results at the lowest cost. Among other parameters costs include processor usage, memory usage, and data pages read.

4. Optimization phase
Once the best execution plan is selected, it is passed to the Execution Engine to process the query.

5. Information from execution plans
Reading execution plans is useful. Among other important information, they can tell us: if indexes were used, the types of joins used, if and where filter conditions, sorting and aggregations occurred, and their relative costs. Any issue with a query should be immediately apparent in an execution plan which makes it an excellent tool for troubleshooting query performance.

6. Estimated execution plan in SSMS
This image shows how we can view an estimated execution plan in SSMS. We highlight the query

7. Estimated execution plan in SSMS
and select the Display Estimated Execution Plan icon from the menu toolbar.

8. Viewing executions plans in SSMS
A graphical execution plan for the query is displayed in the Execution plan tab.

9. Operator statistics
Each icon in an execution plan represents an operator that is used to perform a specific task. Hovering over an operator provides detailed statistics of the task used in the query.

10. Reading execution plans
Execution plans are read from right to left, as indicated by the direction of the arrows between operators. The width of each arrow reflects how much data was passed from one operator to the next.

11. Index example
Let’s take a look at some of the information execution plans can provide us. An execution plan can tell us if an index is accessed while processing the query. In this example, we have two versions of the Customers table from the Customers Orders database. CustomersCI has a clustered index on the CustomerID column, and Customers does not. We’ll query both tables for a CustomerID of PARIS. The execution plan for the query on the Customers table shows a Table Scan operator. This operator indicates the entire table was scanned for the filter condition. In contrast, the execution plan for the query on the CustomersCI table shows a Clustered Index Seek operator. This operator indicates an index was used to go directly to the data pages that meet the filter condition.

12. Sort operator example
In an earlier chapter, we said that we could append queries together using UNION and UNION ALL. We noted that UNION removes duplicates and UNION ALL returns everything, including duplicates. To check for and remove duplicates requires a sort operation. We can see this by comparing two queries with UNION and UNION ALL. The execution plan with UNION uses a Sort operator internally to check and remove duplicates and UNION ALL does not. Be aware of the Sort operator in execution plans because it can be costly on a query. Examining an execution plan could tell us particular syntax or operators that are unnecessary.

13. The same execution plan?
Often, queries using different methods to return the same result will produce the same execution plan. In an earlier chapter, we compared the IN and EXISTS operators. In this example we have two simple queries: one using IN and the other EXISTS. The optimizer has decided to use the same execution plan for both. This is not always the case, and it does not mean that we should let the optimizer do all the query performance tuning for us. If time is important, we should always ask ourselves if there is a better or faster way to return the results we require.