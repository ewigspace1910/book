Got It!
1. Pytest
In this video, we will learn to write pytest tests.

2. Pytest tests
Pytest tests are functions that typically use assert statements. Assert raises an AssertionError if the expression that follows it evaluates to False. In the test_addition() function, we assert that one plus two equals three. Pytest tests can accept multiple arguments from the "@parametrize" decorator. Inside the parentheses after "@parametrize", we name the argument set and then provide a list of arguments. In the test_even() function, we are testing that the arguments in the 'n' argument set are all evenly divisible by 2. In addition to "@parametrize", pytest tests can use the raises() function as part of a "with" statement to confirm an expected error. In the test_assert() function, we are expecting an AssertionError, because one plus two does not equal four.

3. Test-driven development
Let's work through an example of developing a module using test-driven development, a process that puts the emphasis on tests. First, we will define a function called "double()" that has type hints and a docstring, but no code block. Next, we will write a simple test and use the pytest shell command to run it. We expect the test to fail. Running failing test is part of the test-driven development process.

4. Run failing tests
Running a failing test on purpose may seem strange, but this confirms that our test works. Also, failing tests can be powerful motivators! After running the failing test, we work on the module until it passes the test. In our case, we just have to add a code block to our double() function.

5. Run passing tests
Now when we rerun pytest, we see that the module passes. Passing all tests is a milestone. We should celebrate! It is important to stop working on the module after it passes. Before we make any changes to double(), we should write and run a test for that change. Remember, tests come first in test-driven development!

6. Test change
Let's say we want our double() function to raise a TypeError if it does not receive a float. We should first write a test to check for this behavior, using pytest.raises(), and then run the test. After running the failing test, we can edit the module.

7. Make change
One way to enable the module to pass the new test is to use a "raise" statement to raise a TypeError.

8. Make change
A simpler approach would be to turn the 2 at the end of the double() function definition into a float. Multiplying a string by a float raises a TypeError, so we do not have to raise it ourselves.

9. Project organization
Here is an example project that has a test file called "test_mymodule.py" in its "tests" directory. This file contains tests for the "double.py" module, which is in the "mypackage" package. Python packages are directories that contain a __init__.py file. Next, we will look at project documentation generated by Sphinx, a tool that automatically generates documentation from Python code.

10. Project documentation
Sphinx can use the docstrings in our test and module code to generate our project documentation in the form of a webpage. The webpage shown here describes a Python project called Nbless that allows us to work with Jupyter notebooks programmatically, instead of using a graphical user interface (GUI).

11. Module documentation
Inside the Nbless documentation, we can see the type hints and doctrings of three functions. You may remember the nbuild() and nbconv() functions from the previous two coding exercises. In the next two exercises, we will write pytest tests for these two functions.