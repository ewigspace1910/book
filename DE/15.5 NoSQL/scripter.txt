chappter1

Got It!
1. Welcome!
Hello, and welcome to the course! This is Miriam Antona. I am a software engineer, and I will be teaching you the main concepts of NoSQL databases.

2. Topics covered
We will start chapter one by describing the differences between NoSQL and relational databases. After that, we will discover key-value databases. In chapter two, we will learn about document databases. We will study column family databases in chapter three. And in the last chapter, chapter four, we will explore graph databases.

3. About the course
This is a conceptual course, so no coding is required. Throughout the course, we will follow Datazy, a fictional social network where data scientists can share their knowledge and ask questions about data science. We will see how this company implements each kind of NoSQL database for its different needs.

4. NoSQL vs relational databases
Let's start with comparing traditional relational databases with NoSQL databases. Relational databases use tables with rows and columns. A database schema needs to be defined before inserting the data. Changing the database schema later might prove complicated because, on some occasions, we will need to create migration scripts or change the application code. Queries may be slow when joining multiple tables. Relational databases scale vertically, which means they scale by adding more power, for example, CPU or RAM. This is more expensive. They guarantee Atomicity, Consistency, Isolation, and Durability in transactions, also known as ACID transactions. They are typically closed source. NoSQL, originally referred to "non-SQL" or "non-relational", is also interpreted as "Not Only SQL". These non-relational databases, don't use tables with rows and columns. They allow the data to be stored without having to define a schema, with the possibility of changing the structure of the data over time. Queries can be faster because there is no need to join multiple tables. NoSQL databases scale horizontally, which means they scale by adding more machines. This is cheaper than scaling vertically. They sometimes don't support ACID transactions. Most of them are open source.

5. NoSQL vs relational databases
It is important to highlight that NoSQL and relational databases are complementary and can coexist with each other. We can have an application using different kinds of databases depending on the needs.

6. Types of NoSQL databases
The four major types of NoSQL databases are key-value databases, document databases, column family databases, and graph databases. Let's start with the first one.

7. Key-value databases
Key-value databases are the simplest NoSQL databases. They support getting and setting values with an associated key.

8. Key
Here are some examples of keys. A key can be any binary sequence, like text, numbers, etc. Keys must be unique. Keys can also be generated by algorithms. It is not a good option to have long keys because they will use more memory.

9. Value
A value is always associated with a key. A value can be retrieved, set, or deleted by its key. Values can be numbers, strings, JSON objects, images, etc. Most key-value databases restrict the size of the values.

10. Value
These are some examples of key-value pairs.
11. Datazy example
As we will see, a typical use case where key-value databases fit well is in storing the preferences that users have when visiting web pages. Datazy, our fictional company, wants to store this information. Datazy decided to store user preferences into one object to retrieve this information with a fast single get operation. In this example, we can see the key-value pairs for two users. Colon symbols (:) are frequently used as a convention when naming keys. We can see how they separate the word user, the number, and the word preferences.The keys are unique, as every user will have a different number. The language, the color, and the timezone are stored as values.
=====================

1. Advantages and limitations of key-value databases
Welcome back! Now that we're up to speed with the terminology, it is time to deepen our knowledge by studying the advantages and limitations of key-value databases.

2. Advantages - very simple
Let's start with the advantages. Key-value databases are very simple. As we learned in lesson one, we just need a key and a value to form a key-value tuple. There is no need to define a schema, and there is no need to determine the types of keys and values. There are three basic operations to work with a key-value database; Put, Get, and Delete. Put inserts a new key-value tuple or updates a value if the key already exists. Get returns the value by a given key. And finally, Delete removes a key and its value if the key exists. This simplicity leads to fast operations.

3. Advantages - flexible
Key-value databases are very flexible. They allow data types to be changed. Let's suppose that we first assigned this number to this key, and we later decide to change the value to this string. Key-value databases won't typically complain about type changes, as opposed to relational databases. In the same way, we can also add additional information to a given key. In this example, we only have the language as the value, but then, we can add the color and the timezone.

4. Advantages - information stored in memory
Many key-value databases store the information in memory, so reads and writes will be faster than writing to a disk. However, we can lose the data, for example, if the machine suddenly shuts off. That is why some key-value databases combine data persistence on disk and memory, so they take advantage of both types of persistence.

5. Advantages - scalability
In terms of scalability, key-value databases can scale horizontally by using sharding. This technique is outside the scope of this course, but basically, sharding distributes

6. Advantages - scalability
different parts

7. Advantages - scalability
of the data

8. Advantages - scalability
across multiple servers.

9. Limitations
Key-value databases have some limitations. We can only search a value by its key, so we will have a problem if we don't know the key we want to find. Some key-value databases have added extended functionalities to avoid this problem. They can search by value and create secondary indexes to specific value attributes. Some key-value databases can even search by multiple keys simultaneously. However, these queries will not be as complex as we can find when using a relational database. For instance, relational databases allow us to join multiple tables, which enables us to connect data.

------------

Got It!
1. When to use key-value databases
In this lesson, we are going to discuss when key-value databases are suitable and when not.

2. Suitable cases
Let's start with some scenarios where key-value databases are a good fit. Websites store data of user sessions. Key-value databases can store this information using the session identifier as the key and all the information about the session in the value.

3. Suitable cases
Websites frequently store user profiles and user preferences, as we saw in lesson one, in the example of Datazy. The key can be, for instance, the user identifier. The user profile information and user preferences can be stored in the value within a single object.

4. Suitable cases
Key-value databases are also suitable for storing the data of shopping carts. The key can be the user identifier, and the value can be all the shopping cart information.

5. Suitable cases
Key-value databases also fit well with real-time recommendations. For example, when a person visits a commercial web page, the key-value database can present new items that the user may like.

6. Suitable cases
And finally, advertising. Key-value databases can help to show advertisements quickly while the user navigates throughout a web page.

7. Suitable cases
They all have in common that they store the information as the value in a single object. This information could be saved just with one operation, for example, with this SET command if we used the Redis database. User, colon, 457, colon, preferences would be the key, and the rest would be the value. Consequently, this information could also be retrieved with another operation, the GET command in this example. This simplicity makes it very fast.

8. Unsuitable cases
By contrast, there are some situations where key-value databases are not a good option. When there is a need to search a key based on its value, key-value databases are not typically an option. Key-value databases don't search by value, although as we saw in the previous lesson, some products support these kinds of advanced options.

9. Unsuitable cases
A typical example where we would like to retrieve a key based on a value could be when retrieving all the users who live in New York City. Also, if your data has to be related to other data, key-value databases would not be the best fit.
============
1. Redis case study
In this final lesson of chapter one, we will cover the case study of Editoo, a company that uses the Redis database.

2. Redis - overview
Redis stands for Remote Dictionary Server. It is one of the most popular key-value databases, but it offers more features than a basic key-value database. Redis is a fast in-memory data structure store. It works with an in-memory dataset to achieve maximum performance, but it additionally allows to persist the data to disk. It can be used as a database, cache, or message broker. Redis is open source. Redis Labs, the company that sponsors the Redis database, has more than 400 employees.

3. Redis - data structures
Redis supports many data structures, which allows users to use Redis in more ways than a simple key-value database. Let's see some examples. Strings are the simplest type of value. In this example, with the SET command, we are setting the string "Ann" as a value for the key "name". We can create lists of elements. Here, we can see how to add the numbers 1, 2, and 3 to the right of a list called "my_numbers". Sets are unordered collections of strings. With the SADD command we can add these numbers to this set. We can also perform some operations such as the intersection, union or difference between multiple sets, etc. Hashes are collections of field-value pairs. In this example they key is user 123, and the hash has two field-value pairs, "name Ann", and "surname Smith". There are more data structures. For a deeper understanding of them and their commands,

4. Redis - data structures
please consult the official Redis documentation.

1 https://www.redis.io/commands
5. Redis - features
Redis supports atomic operations on these types. An atomic operation means that the operation is guaranteed to either complete fully or not at all. Redis also supports transactions, allowing the execution of a group of commands. Either all of the commands or none are processed. For complex operations, we can write scripts using the Lua programming language. We can use Redis from most programming languages, like Python, R, C#, Java, JavaScript, PHP, and much more. Redis also offers by default asynchronous replication; that is, the data is first copied to the primary storage and then copied to the replica.

6. Redis - popular uses
These are some popular uses of Redis. Redis is often used for caching, for example, query results or objects frequently used, such as images or files. It is also used for session storage, for instance, to store user profiles, credentials, etc. Other common uses are chatting, messaging, and queues. Redis can be used in chat rooms, real-time comments, social media feeds, etc. Real-time analytics, like social media analytics or advertisement, are also popular uses. Redis can be helpful with gaming leaderboards, displaying ranked lists in real-time with user scores.

7. Redis - on the cloud
Some established cloud providers offer services packaged with Redis. For example, Amazon Web Services offers Elasticache for Redis, Microsoft offers Azure Cache for Redis in Azure, and Alibaba is offering ApsaraDB for Redis in Alibaba Cloud.

8. Redis - customers
Here are a few Redis customers.

9. Editoo case study
One company that uses Redis is Editoo. Editoo is a small business that sells an online tool to create custom magazines for either personal or business goals. Editoo began having high latency because more people started using its web application. The company used a traditional relational database management system that couldn't handle that increase in traffic. Editoo decided to use Redis to store its user sessions and caching database queries.

10. Editoo case study
Thanks to Redis, the company has seen a reduction in downtime and a higher performance. Following this first success, Editoo decided to migrate more of its relational databases to Redis.

11. Editoo case study
You can find more case studies of Redis on the link below.

#############################
Chapter2
#################################

Got It!
1. What is a document database?
Welcome to this second chapter! In the previous chapter, we learned the basics of key-value databases. In this chapter, we will discover document databases. Let's start!

Documents are grouped into collections.

8. Document database - overview
We can have

9. Document database - overview
multiple collections within a database. If you are familiar with relational databases, we can say that documents are analogous to rows and collections to tables.

10. Documents
A document is a set of key-value pairs. The keys are strings and the values can be numbers, strings, booleans, arrays or objects. As document databases are schemaless, there is no need to specify the structure of the documents. Documents can encode the data in JSON, BSON, YAML, or XML formats. Throughout this chapter, we will focus on JSON format, as it is the most popular.

11. Documents - JSON format
Here is an example of a document in JSON format. It stores the information of every user registered at Datazy. As we can see, data is organized in key-value pairs separated by commas. The value for the "address" key is another document. Notice that this related information is embedded in the main document, avoiding the need to look for the address in another place. The value for the "hobbies" key is an array. Its elements are separated by commas and surrounded by square brackets.

12. Documents - queries
Unlike key-value databases that we studied in the previous chapter, we can elaborate more complex queries with document databases. For instance, we can get all the users who live in New York and like hiking, get all the users older than 40, or simply get all the user's data by a given user identifier. We will see some query examples in the lesson dedicated to MongoDB.

13. Documents - polymorphic model
Document databases are polymorphic. It means that documents within the same collection don't need to have the same structure. For instance, these two documents describe Datazy users, but the information they have is different. The document on the right doesn't have the address information, but it has the date of birth.

14. Collections
As we said before, collections are sets of documents. Usually, collections store the same type of entities, such as users, products, etc., but they don't mix different types of entities. A good way to organize documents and collections is by thinking about the queries we want to get in our application. There are best practices of modeling, but they are out of the scope of this course.

15. Popular document databases
Here are some popular document databases.
-------------------
1. Advantages and limitations of document databases
Congratulations on completing the exercises! In this lesson, we will deepen our knowledge by studying the advantages and limitations of document databases.

2. Advantages - flexibility
Let's start with the advantages. Document databases are flexible. As we learned in the previous lesson, we don't need to predefine the schema. Documents can vary over time, but with document databases, we will avoid complex migrations when changes happen. With embedded documents, we don't need to join tables like in relational databases. The joining process can be potentially time-consuming if the tables are large or if we are joining many tables, so we can get better times with document databases. The flexibility advantage is one of the first reasons why developers choose document databases for their projects.

3. Advantages - intuitive for developers
For developers, working with documents is very intuitive and a natural way to work with. JSON documents are human-readable, being a friendly way to represent the data. Documents can map to the objects in the code, which implies less coding and a simpler and faster development task. For example, we can have in our code an object with properties representing a user. This object can have the same structure that a document with the information of a user. Programmers can start coding and storing objects as documents are created. For new developers, this way of programming can be easier.

4. Advantages - horizontal scalability
As we saw with key-value databases, document databases can scale horizontally by using the sharding technique.

5. Limitations - more responsibility
On the other hand, document databases have some limitations. As they are schemaless, we will have to be more responsible and care about data in the application code. For example, if the email account is always required when signing up a user, we will have to check in our code if this information has been received. This scenario is simple, but more complex ones can occur. Another point to take care of is redundant data. We may introduce redundancy for optimizing, but we must remember which data is redundant. Let's suppose that we need to display a customer name in several parts of our application, so we decide to duplicate the name in different documents to optimize the queries. If we need to modify the name, we will have to remember that we must change it in all the documents.

6. Let's practice!
Great job! Let's take some exercises before studying the scenarios where document databases are suitable.
********
2. Suitable cases
Let's start with some scenarios where document databases are a good fit. The first use case we are going to present is the storage of catalogs. For instance, e-commerce websites and applications store catalogs of their product information. As we saw before, documents can be polymorphic, so document databases are helpful in this scenario because each product may have different attributes compared to other products. Besides, we can embed related information like the product category and retrieve all of this information with a single query.

3. Suitable cases
Applications may want to store the events that occur, such as the logging of a user, the purchase of a product, errors, etc. As the volume of events may be high, the sharding technique can be helpful. Events can be sharded by time, by the type of event, etc.

4. Suitable cases
Document databases also fit well for storing user profiles, as we saw in the example of Datazy. Users can add or remove information, so their profiles may vary over time. As documents are flexible in that way, document databases are a good choice for storing user profiles.

5. Suitable cases
The domain of content management systems, like blogs or video platforms is also suitable for document databases. The content that the users create such as comments, images, videos, etc., can be saved in document databases.

6. Suitable cases
Finally, document databases are a good option for storing data for real-time analytics. Many companies track real-time performance metrics such as page views, unique visitors, etc. Even if new metrics are needed, it will be very easy to add them.

7. Unsuitable cases
Document databases have evolved a lot in recent years, offering transactions, security controls, powerful query engines, etc. These features mean document databases are used in more cases than they used to. However, if we already have very structured data, document databases will not be the best solution. Also, if we want our data to always be consistent, we have to know that some document databases don't ensure consistency.
**************
1. MongoDB case study
In this final lesson of chapter two, we will cover the case study of Shutterfly, a company that uses the MongoDB database.

2. MongoDB - overview
MongoDB is one of the most popular document databases. It stores the data in a format called BSON, which means Binary JSON. BSON is a binary representation to store data in JSON format.

3. MongoDB - features
MongoDB offers MQL, or MongoDB Query Language, which allows us to create complex queries for the data. For example, this code finds all the users whose zip code is 10245. MongoDB provides native drivers for many programming languages such as C#, Java, Python, Scala, etc. It allows us to declare indexes on any document field. As relational databases, it supports ACID transactions, that is, Atomicity, Consistency, Isolation, and Durability; and joins in queries.

4. MongoDB - features
MongoDB can scale horizontally across multiple nodes through native sharding without adding complexity to the application. Shards can be removed or added at any time. MongoDB offers replication so that there is no single point of failure. We can create up to 50 copies of our data across different servers and geographic regions.

5. MongoDB - products
These are the most important products that MongoDB offers. MongoDB Compass is the free Graphic User Interface where we can explore our schema, create queries visually, and much more. MongoDB Atlas is the cloud database service. It can be fully managed across Amazon Web Services, Azure, and Google Cloud. With MongoDB Enterprise Advanced, we can run MongoDB in our infrastructure.

6. MongoDB - products
MongoDB Atlas Data Lake allows the querying and analyzing of data across Amazon Web Services S3 and MongoDB Atlas using the MongoDB Query Language. With MongoDB Charts, we can create visualizations of the data. And finally, Realm Mobile Database allows developers to store data locally on iOS or Android devices.

7. MongoDB - popular uses
Let's see some popular uses of MongoDB. MongoDB is frequently used in single-view applications, which gather data from multiple sources to create a single view. Some example applications include financial services, government, high tech, and retail. Gaming is another use. MongoDB can store data such as player profiles, leaderboards, etc. Another common use is catalog storage, with financial services, government, high tech, and retail, again being the main applications. Real-time analytics, content management, and the Internet of Things are also popular uses.

8. MongoDB - customers
Here are a few MongoDB customers.

9. Shutterfly case study - overview
One company that uses MongoDB is Shutterfly. Shutterfly is an online photography service. Users can share their memories by creating personalized photo albums. The company also offers personalized products with printed photographs. Shutterfly has millions of customers and stores more than six billion images.

10. Shutterfly case study - problem and solution
Shutterfly's data started to grow a lot because their platform doesn't compress, force delete, or down-sample photos. The company used the Oracle relational database, and this growth pushed the performance limits of this database. Thus, applications took a long time to build properly and didn't perform quickly enough. Oracle became too expensive for this deficient performance. These reasons lead Shutterfly to analyze other databases and finally chose MongoDB.

11. Shutterfly case study - results
The switch from Oracle to MongoDB produced a performance improvement. For instance, the average latency for inserts dropped from 400 milliseconds to 2 milliseconds. MongoDB enabled Shutterfly to scale horizontally. With MongoDB's flexible schema, Shutterfly's development cycles are shorter. As a result, developers can quickly develop and deploy new applications. Special features like tags, comments, etc., are not challenging to implement anymore. MongoDB also allows new query patterns that were non-viable with Oracle. All of this resulted in cost reduction.
2. Shutterfly case study - results
You can find more case studies of MongoDB in the link below.

1 https://www.mongodb.com/who-uses-mongodb

#############################
Chapter3
#################################
1. What is a column family database?
Congratulations on finishing chapter two! In the previous chapter, we learned the main concepts of document databases. Now, let's discover column family databases!

2. Column family databases - overview
Column family databases derive from the Google BigTable data storage system. They store the information in column families, that group related data frequently accessed together. Column family databases are also called wide column databases. They are great when dealing with large volumes of data.

3. Column family databases - structure
Let's analyze the structure of a column family. A column family

4. Column family databases - structure
can have

5. Column family databases - structure
multiple

6. Column family databases - structure
rows. A column family is like a table in a relational database.

7. Column family databases - structure
Each row has a unique row key identifier. Row keys are like primary keys in a relational database.

8. Column family databases - structure
Each row contains columns but can have a different number of columns than other rows. Columns can be added to the rows when they are needed.

9. Column family databases - structure
The parts of the columns are the name, the value, and the timestamp.

10. Column family databases - structure
Depending on the column family database, we may specify the data types of the values, like integers, strings, lists, etc.

11. Column family databases - structure
Timestamps store the date and the time when the data was inserted. If we update the value of a column, a new timestamp will be inserted along with the column name and value. This versioning allows us to store multiple values of a column but knowing which one is the latest value.

12. Column family databases - example
For instance, if we wanted to store our application users' information, we could do something like this. As we can see, each row contains a different number of columns. The first row doesn't have the date_of_birth column; the second row doesn't have the address or the date_of_birth columns, and the last row doesn't have the address column. If we want any of these rows to have a new column, we can add it when we need it.

13. Column family databases - designing
Regarding the design of column-family databases, we have to think about the queries we will use in our application and include that information into column families. It is important to know that column-family databases don't support joins, so we will need to add all the columns we need for a query.

14. Popular column family databases
Here are some popular column family databases.

1. Advantages and limitations of column family databases
In this lesson, we will study the advantages and limitations of column family databases.

2. Advantages - flexibility
Column family databases are flexible. As we learned in the previous lesson, rows within the same column family can have a different number of columns, and we can add new columns to a row if we need them. This flexibility avoids filling the new columns with default values for the existing rows, as it happens with relational databases. Flexibility is a great advantage, but it mustn't be considered the only criterion when choosing column family databases, especially if we don't need to handle big data. If we are just considering flexibility, we should also evaluate key-value and document databases.

3. Advantages - speed
Another advantage of column family databases is the speed. The information of the related columns within the same column family is stored together on disk, writing and retrieving information faster than if the data was stored in different parts of a disk.

4. Advantages - scalability
Like other NoSQL databases we have studied, column family databases scale horizontally by sharding across multiple servers.

5. Advantages - large volumes of data
Column family databases are designed to handle large volumes of data. This is due to the speed and the horizontal scalability we mentioned earlier, as well as an efficient data compression.

6. Limitations
Column family databases also have some limitations. Although this kind of database supports atomic reads and writes to a single row, it doesn't support multirow transactions. It means that if we need more than one operation within the same transaction, we won't be able to perform it. For example, if we want to update in the same transaction a row that belongs to one column family and then another row that belongs to another column family. Another limitation is that column family databases don't support joins or subqueries, as data within column families is intended to be related and retrieved together. Finally, we should define the queries quite well before modeling the column families. If the queries change, we may also need to modify the schemas of the column families we already designed, and it can be costly.

==================

Got It!
1. When to use column family databases
In this lesson, we are going to discover when column family databases are suitable and when not.

2. Suitable cases - general cases
In general, column family databases are great when dealing with large volumes of data. They are also frequently used when we need extreme write speeds. We will discuss several scenarios that are a good fit for column family databases if these conditions are required.

3. Suitable cases - event logging
The first use case we are going to discuss is event logging. As we learned in the chapter dedicated to document databases, applications may want to store the information of the events that occur, such as a user logging in, application errors, etc. This information can be saved in a column family database.

4. Suitable cases - Content Management Systems
Again, similar to document databases, content management systems are also suitable for column family databases. Comments, links, tags, etc., can be saved in this kind of database.

5. Suitable cases - time-series data
Column family databases are also a good option for storing time-series data, such as monitoring the weather, the traffic, etc.

6. Unsuitable cases
By contrast, there are some situations where column family databases are not a good choice. Column family databases are not the best option when prototyping or at the beginning of a project because it is quite sure that we will need to change the queries very frequently. As we said in the first lesson of this chapter, column family databases are modeled by thinking about the queries we want to have in our application. Changing the queries may imply changing the schemas of the column families, which can be costly and may slow down productivity. Also, if we need to create complex queries or if we need to join data across column families, this kind of database won't be the best option for our applications. And finally, if we are not dealing with large amounts of data, a column family will probably be more than we need.
--------------------

Got It!
1. Apache Cassandra case study
Let's end this chapter by looking into Bigmate's, a company that uses the Apache Cassandra database.

2. Apache Cassandra - overview
Apache Cassandra is one of the most popular column family databases. It was originally developed by Facebook and then released as an open-source project. Nowadays, it is managed by the Apache Foundation.

3. Apache Cassandra - features
Apache Cassandra is distributed, which means that it can run on multiple machines as if it was one. Data is distributed across the nodes of the cluster, and every node plays the same role. There is no master node. It provides high availability with no single point of failure. Apache Cassandra scales horizontally by adding nodes. It has several client drivers that allow us to work with many programming languages, such as C#, Java, Python, Scala, etc.

4. Apache Cassandra - features
Apache Cassandra also offers the Cassandra Query Language, also known as CQL. CQL is used to query data stored in Cassandra databases. It has a similar syntax to SQL and also works with tables, in which we store the column families. Tables have rows and columns. However, it has fewer functionalities. For instance, it doesn't support joins, foreign keys, or subqueries. Each row within the same table can contain a different number of columns. This is an example of a select statement in the Cassandra Query Language. With it, we can get from the users table all the users whose user_id is 212, 213, and 214.

5. Apache Cassandra - ecosystem
Cassandra's ecosystem includes third-party Cassandra projects, tools, products, and services, but the community does not support them. Some of these projects include services such as cloud offerings, installation tools, developers' frameworks, connectors, etc.

6. Apache Cassandra - customers
Here are a few Apache Cassandra customers.

7. Bigmate case study - overview
One company that uses Apache Cassandra is Bigmate. Bigmate provides solutions for location tracking, industrial sensor, and productivity to a broad range of industries and markets.

8. Bigmate case study - problem and solution
Bigmate built an Internet of Things platform that ingests and processes large volumes of different data. They needed to integrate several Internet of Things sensors, devices, and other platforms, process the data in real-time, and scale to deploy across multiple locations. One application included in this platform is Thermy that uses a thermal camera to capture the skin temperature of people and helps to identify temperature irregularities in real-time. Another application is Warny that detects possible collisions among worksite vehicles and workers and sends preventative alerts. Bigmate tested some databases such as MySQL, MongoDB, and Apache Cassandra. The company finally chose Apache Cassandra because it scaled much better than the other databases.

9. Bigmate case study - results
With Apache Cassandra, Bigmate can handle millions of operations of concurrent users each second. They are able to display 20,000 real-time data points to a single customer. The database also achieves fault tolerance as it replicates the data automatically across multiple nodes.

10. Bigmate case study - results
You can find more case studies of Apache Cassandra in the link below.

1 https://cassandra.apache.org/case-studies/

#############################
Chapter4
#################################

1. What is a graph database?
Welcome back! In the previous chapter, we learned the main concepts of column family databases. Let's end this course by studying the basic concepts of graph databases!

2. Graph databases - overview
Graph databases are designed to treat data and its relationships with the same importance. They are based on graph theory, which is a branch of mathematics that studies the graphs for modeling the relationships between objects.

3. Graph databases - parts of a graph
Graphs are structures that have two parts. The vertices, also called nodes, and the edges,

4. Graph databases - parts of a graph
also known as links or arcs.

5. Graph databases - nodes
Nodes represent entities, for example, users, cities, airports, employees, etc. Let's represent the users of the Datazy social network with a graph. Nodes can have properties,

6. Graph databases - nodes
such as the name, surname, email, date of birth, etc.

7. Graph databases - edges
Edges connect the nodes and define

8. Graph databases - edges
the relationships between the nodes. In this example, we can see that Carol follows Ben and Shui, Ben also follows Shui, and Shui follows Carol. Edges also have

9. Graph databases - edges
properties. Here we can see that the property of the edges is the year when a user started to follow another user.

10. Graph databases - types of edges
There are two kinds of edges. Edges are directed when they have one specific direction. For example, Carol likes post number one and post number two, and Ben likes post number 2.

11. Graph databases - types of edges
Edges can also be undirected when they have no direction. In this case, we assume the relationship is mutual. For example, we can model the friendship between Ben and Daya with undirected edges, assuming that both are friends.

12. Graph databases - queries
Querying the graph is called traversing the graph. For instance, in the first example we saw, we can get all the users that Ben follows, or get when Carol started following Shui. In a graph where nodes represent cities, and the edges represent the highways that connect the cities with their distances, we can get the shortest path from one city to another. The set of nodes and their edges across a graph is called a path. Graph databases support query languages such as Cypher or Gremlin to retrieve and store data.

13. Popular graph databases
Here are some popular graph databases.
1. Advantages and limitations of graph databases
In this lesson, we will deepen our knowledge by studying the advantages and limitations of graph databases.

2. Advantages - flexibility
Let's start with the advantages. Graph databases are flexible and can change as applications and industries change. We don't need to define the final structure of a graph in advance. Thus, if we need to add or delete nodes, properties, and edges to the existing graphs, we can do it without worrying about the current information that we already stored.

3. Advantages - performance
Another advantage of graph databases is their performance. This kind of database doesn't need to perform joins. It should be remembered that the joining process can be potentially time-consuming. Instead, we can simply follow edges from node to node, which is much simpler and faster, even for complex queries or large volumes of data.

4. Advantages - easy representation of the data
Another benefit is that graph databases have an easy representation of the data. The structure of a graph is comparable to human thinking. Graphs map in a more realistic way than other databases, similar to how human brains map and process the world. It makes graph modeling very intuitive. Graphs are easily visualized with the nodes, relationships, and associated properties. This type of representation facilitates understanding.

5. Advantages - horizontal scalability
Horizontal scalability in graph databases is possible. However, it is more difficult than in other NoSQL databases because graphs are connected, and they need to be distributed across multiple machines.

6. Limitations
Graph databases also have some limitations. As we will see in the next lesson, some scenarios are unsuitable for graph databases, such as having entity properties containing extremely large values, like BLOBs, Binary Large Objects, which are typically multimedia objects, or CLOBs, Character Large Objects, which are collections of character data. The reason is that these databases won't perform well, and in fact, it is considered a bad practice. If we need to handle them, it is better to use another type of database to store that information and use the graph database, for instance, just to store the URL that points to the binary data. Finally, graph databases may be a significant change for developers that are used to working with relational databases. They will need to adopt a new data modeling mindset and learn a new query language such as Cypher or Gremlin.

Got It!
1. When to use graph databases
In this lesson, we are going to learn when graph databases are suitable and when they are not.

2. Suitable cases - General information
In general, graph databases are suitable when dealing with highly connected data. In the following slides, we will discuss several scenarios that are a good fit for graph databases under this condition.

3. Suitable cases - Social graphs
Let's start with social graphs. Social information can be modeled using graph databases. As we saw at the beginning of this chapter, we can store information about social networks, such as the users and their relationships, the posts they write, the likes, etc. Other social interactions can be represented. For instance, we can model the employees of a company, the projects they work on, or relations between the employees.

4. Suitable cases - Infectious diseases
Another suitable case for graph databases is the modeling of infectious diseases. The COVID-19 pandemic has shown how important it is to analyze the world as a whole. Graph databases can be used to model the interactions between people, contact events, or exposures. In this domain, graph databases can help to understand transmission chains.

5. Suitable cases - Location services
Graph databases can also represent locations and distances between these locations. With this information, we can optimize the routes for navigation applications, or we can even provide recommendations for nearby points of interest, like restaurants, cinemas, hospitals, etc.

6. Suitable cases - Fraud detection
Graph databases can help stop fraud scenarios in real-time, such as credit card fraud, e-commerce fraud, and money laundering. For example, we can model with a graph the interactions between individuals with their credit cards, phone numbers, devices, IP addresses, etc., and uncover suspicious patterns that other kinds of databases might find difficult to detect, like multiple users coming from the same IP address.

7. Suitable cases - Real-time recommendations
With graph databases, we can create real-time recommendations. For example, we can store the buying history of the users and their browsing behavior to immediately recommend an item they may like, or we can even offer this recommendation to another user who is a friend. We can also recommend unwatched movies to a user by searching on the graphs for other movies watched by similar users.

8. Suitable cases - Networks
Another suitable case for graph databases is the storage of relationships between networks and their infrastructure elements, such as physical machines, virtual machines, applications, routers, switches, etc. In this domain, graphs can be used, for example, to alert in real-time about potential design flaws.

9. Unsuitable cases
By contrast, there are some situations where graph databases are not a good choice. Graph databases are not the best option when data is disconnected, or the relationships between the data are not important. Applications that only perform general searches, where we need to search the entire graph without a specific starting point, are not the best option for using graph databases, either. Although graph databases can handle those queries, they are not optimized for maximum performance. Finally, graph databases are not recommended when there are entity properties that contain extremely large values, like BLOBs, CLOBs, etc.


Got It!
1. Neo4j case study
In this final lesson, we will cover the case study of Gousto, a company that uses the Neo4j graph database.

2. Neo4j - overview
Neo4j is considered the leader in graph database technology. The company ended in 2020 with over 420 employees. Neo4j helps to reveal and predict how people, processes, and systems are interrelated.

3. Neo4j graph platform
The Neo4j graph platform is a suite of applications and tools that allow users to interact with and use Neo4j's graph data in various ways. Let's see its components.

4. Neo4j graph platform - Graph database
The Graph database is the core of the platform. With this native graph database, we can store and connect the data.

5. Neo4j graph platform - Graph data science library
The Graph data science library is used for executing graph algorithms, such as path-finding, centrality, community detection, similarity, link prediction, node embeddings, and node classification. For example, path-finding algorithms can find the shortest path in a graph.

6. Neo4j graph platform - Bloom
Neo4j Bloom is a visualization tool to view and analyze data without having any programming knowledge. Users can interact with their graph data.

7. Neo4j graph platform - Cypher
Cypher is a powerful query language we can use in the Neo4j database. It is inspired by SQL and allows users to save and get data from the graph database. With Neo4j it is possible to run multiple queries in Cypher within the same transaction. The following code is an example of Cypher. It is used to add a node to the graph of type User with the name Ann.

8. Neo4j graph platform - Connectors and Integrations
Neo4j Connectors and Integrations facilitate the use of Neo4j in existing architectures. We have the Neo4j Connector for Apache Spark, the Neo4j Connector for Apache Kafka, the Neo4j Connector for Business Intelligence, and the Neo4j Labs Integrations.

9. Neo4j graph platform - Developer tools
Neo4j Developer Tools make it easier to develop graph applications. These tools are Neo4j Desktop that allows working with local Neo4j databases. Neo4j Browser, which lets users interact with the graphs using a browser. And finally, Sandbox. It is helpful to learn about Neo4j, test personal ideas, etc.

10. Neo4j graph platform - Aura
The last component is Neo4j Aura. It is the Cloud Database Service. With Aura, we can run the Neo4j Database Management System in the cloud without managing the infrastructure.

11. Neo4j - drivers
Neo4j has several official drivers that allow us to work with many programming languages, such as C#, Java, Python, JavaScript, and Spring. The Neo4j community has also contributed to developing drivers for other programming languages such as R, PHP, and Ruby.

12. Neo4j - popular uses
Some popular uses of Neo4j are analytics and artificial intelligence, fraud detection, real-time recommendations, knowledge graphs, life sciences, telecommunications, etc.

13. Neo4j - customers
Here are a few Neo4j customers.

14. Gousto - overview
One company that uses Neo4j is Gousto, a recipe box company that sends measured ingredients and recipes directly to their customer's homes. It delivers over a million meals each month. Gousto employs more than 400 people.

15. Gousto - problem and solution
The company grew its menu to offer more choice, but that implied that the menus were difficult to navigate. The company wanted to make it easier for its clients to find the dishes they liked, but it was unclear what drove customers' food choices. For Gousto, the solution was to use the Neo4j database. The company created an internal recommendation system with the recipes each customer would enjoy most. The data sources used by the system are the subscriber's previous interactions with the menu and the information on upcoming recipes.

16. Gousto - results
Since Gousto started using Neo4j, the number of customers that select recommended recipes has increased by 30%. The company also has better cost control due to more accurate and sustainable product sourcing.

17. Gousto - results
You can find more case studies of Neo4j in the link below.

1 https://neo4j.com/case-studies/
