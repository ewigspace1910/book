1. The distinct() method
In this lesson, we'll learn to use the "distinct" method on Mongo collections. Using this method, we can collect the set of values assigned to a field across all documents.

2. An exceptional laureate
We found an exceptional laureate in the last chapter. This laureate has received three Nobel prizes, more than any other laureate. Here we can see that this is the International Committee of the Red Cross. You may not have known that organizations can win Nobel prizes, but they have. For example, 23 employees of Lawrence Berkeley Lab shared the Nobel Peace Prize in 2007. They were part of the Intergovernmental Panel on Climate Change. A future exercise will be about the proportion of Nobel prizes awarded to immigrants. Keep in mind that the idea of immigration doesn't apply to some laureates. In this document, I see that the "gender" field has a value of "org", presumably short for "organization". What are the values that this field stores across documents in this collection? MongoDB provides a built-in collection method for such aggregation.

3. Using .distinct()
Here, we call the "distinct" method on the laureates collection. We pass a single argument, "gender". MongoDB collects the distinct values that this field takes across the collection. We see that there are three and only three values for the "gender" field across the collection. You may be wondering where this method comes from, or how you can define a similar operation yourself. The "distinct" method is a convenience for a common aggregation. The "count_documents" method we have been using is a similar convenience. An aggregation processes data across a collection and produces a computed result. In the last chapter of this course, we'll learn how to create custom aggregations. You may be wondering about the efficiency of aggregations in MongoDB. You can register so-called "indexes" on fields for MongoDB to maintain. These indexes can ensure efficient queries and aggregations. In some cases, a query might not even need to run on a collection. We will learn how to create indexes in the next chapter. But, if we're not working with a lot of data, indexes are generally not needed. The laureates collection we're using in this course fits in memory. It weighs in at under a megabyte and has on the order of a thousand documents or fewer. It doesn't matter much if you use an inefficient algorithm to sort a list of a few hundred items. Likewise, a full collection scan isn't a big deal for this aggregation.

4. .distinct() with dot notation
You can use dot notation to specify fields embedded deeper than the root level of a document. This applies in query methods like "find" and "find_one", and it applies for aggregations as well. I notice here that each subdocument in the "prizes" array field has a "category" field. The dot-two in the filter denotes index two of an array field. Thus, this is a laureate where a third element exists in the prizes array. Let's fetch the distinct values of this field. We see, as expected, that there is a value for each category of Nobel prize.
------
Got It!
1. Pre-filtering distinct values
In this lesson, we're going to dip our toes into the world of aggregation pipelines. We'll use the "filter" parameter of the "distinct" method to match certain documents. The method will fetch field values only from these matching documents.

2. Awards into prize shares
Here I've found a laureate document with a value of "4" for the "share" field in one of it's "prizes" subdocuments. Pierre Curie shared the 1903 Nobel Prize in physics with his wife Marie. They also shared it with physicist Henri Becquerel. Marie and Pierre each received a quarter share of the prize. Henri received the remaining half share. The Nobel Prize API encodes prize share - in particular, the denominator of the fractional share - as a string. Thus, the document records Pierre's quarter share as the string "4".

3. High-share prize categories
Which Nobel prize categories other than physics have laureates with quarter shares? We know how to get the distinct values of prize categories from the laureates collection. We pass the dotted path "prizes-dot-category" to the "distinct" method. We also know how to find - and list - all laureate documents satisfying some criteria using a filter document. Can we compose these two ideas? Sure! The "distinct" method takes an optional filter argument. You can think of this as a two-stage pipeline. First, filter the collection for documents that match a filter. Then, collected and return distinct values of a field for these documents. In the last chapter of this course, we'll learn how to custom-build such pipelines in an explicit way. The Nobel Prize API serves its data in a denormalized way. Thus, we can answer our question from a different perspective. Here, we ask the "prizes" collection to return distinct prize categories. Given a filter on laureate shares, we return distinct values of the "category" field. The result is the same as the call above using the laureates collection.

4. Prize categories with multi-winners
Let's look at one more example of pre-filtering distinct values. Which prize categories have laureates who have won more than one prize? We'll start by counting laureates who won at least two prizes. In other words, those for which a second element exists in their document's "prizes" array. Next, we pass this filter document as a second argument to the "distinct" method. Our first argument is the dotted path to the prize category field. This returns all prize category values with laureates who have won more than one prize. Here are the corresponding prize categories for these six laureates. Notice that not all won prizes in the same category. Marie Curie, for instance, won prizes in both physics and chemistry. Linus Pauling won prizes in both chemistry and peace. We'll learn in the next chapter how to fetch only the document substructure we need. In this case, the MongoDB server returned only enough to communicate prize categories.
------
1. Matching array fields
In this lesson, we'll learn more about how to query array fields and their structured values.

2. Array fields and equality
Here we see part of the laureates collection document for John Bardeen. He won two prizes, both in physics. Each prizes array in a laureate document contains subdocuments. Each subdocument has a category field. We can use dot notation to filter for and count laureates with a prize category equal to physics.

3. Array fields and equality, simplified
Here's a simpler example using a fictitious field. Let's imagine that laureate documents had an extra field, "nicknames". This field stores an array of string values. Let's now find all laureates with a nickname of "JB". We could use a filter document like this. The filter matches all documents that have at least one value in the "nicknames" array field equal to "JB". This notation is familiar. If "nicknames" was not an array, the filter would match for the field value being equal to "JB". Because "nicknames" is an array, the filter matches if any member of the array matches.

4. Array fields and operators
Let's go back to filtering on the real "category" field. This field is within subdocuments of the top-level "prizes" array field. As before, we can wrap filter document values with operators. For example, here we filter for laureates with a prize not in physics. Note that these documents may contain a prize subdocument with a category of physics. They need only also contain a prize subdocument with another category value. Another example. Here, we use the "in" operator to find laureates with at least one prize in these three categories. And here, we use the "not-in" operator to find laureates with at least one prize not in these three categories.

5. Enter $elemMatch
But what if we want to filter on more than one field within a prize subdocument? Let's try something like this to count laureates who won unshared prizes in physics. Hmm, that's not quite what we want. This filter matches prize subdocuments that have two and only two fields. No laureates have a prize subdocument that looks exactly like this. All prize subdocuments also have a year field, for instance. This next filter is better, but it's not quite what we want. This filter matches laureate documents satisfying two conditions. The first is that a prizes field has at least one subdocument with a "category" field equal to "physics". The second is that that a prizes field has at least one subdocument with a "share" field equal to "1". The prizes that match for a laureate could be different prizes. This is where the "element match" - or "elemMatch" - operator comes in. Finally, we count all laureates that have at least one unshared prize in physics. Within the "elemMatch" operation, as with any operation, we can continue to drill down. Operations can nest to make finer-grained queries. Here, we extend the last filter to include laureates only if they won a solo prize in physics before 1945.
------
Got It!
1. Distinct As You Like It: Filtering with Regular Expressions
We've seen how to construct filters comparing a field's value exactly. For string-valued fields, we may want instead to match a field's value to a pattern. We may want to match a substring. We may want to constrain that substring to appear at the start or end of a field's value. Or, we may want something more complex. Regular expressions are a powerful way to express such filters. Let's see how MongoDB supports them.

2. Finding a substring with $regex
Let's look at the laureate document for Marie Curie. Recall that she discovered a new element and named it polonium. She did this to publicize her native land's lack of independence. We see here that Poland is a substring of her document's "bornCountry". How can we filter for values of "bornCountry" that contain Poland as a substring? We can use MongoDB's regular expression operator, regex. Here I use the regex operator on the string "Poland" in a filter document. This expression gets distinct values of "bornCountry" that contain "Poland" as a substring. The results show that some laureates were born in places that at the time were not part of Poland but today are. Others were born in places that at the time were part of Poland but today are not. And finally, some were born in places that both at the time were and today are part of Poland.

3. Flag options for regular expressions
We can use the regex operator together with the options operator. This will change the conditions for matching. For example, the "i" option ensures case-insensitive matching. The string passed to regex in the second statement is "poland", all lower case. The assertion here is true - Poland is always capitalized for this field. MongoDB also supports compiled regular expression objects. The pymongo driver includes a bson package with a Regex class, which you can import and use as shown. Finally, using native Python regular expression objects is possible. I do not recommend this, though. Use of the bson Regex class is more robust for MongoDB.

4. Beginning and ending (and escaping)
The syntax of regular expressions is rich. For the exercises, though, you only need to know a few tricks. First, you need to know how to match the beginning or end of a field's value. Second, you need to know how to escape a special character so that you match the character itself. To match the beginning of a field's value, use the caret character. Anchor it to the beginning of the string you pass to regex. This expression returns distinct values of the "bornCountry" field that start with Poland. To escape a character, use a backslash. A paren functions to capture groups in regular expressions. Because we want to match a literal open paren and not use this function, we escape it with a backslash. This expression returns "bornCountry" values for countries that used to be Poland. Finally, to match the end of a field's value, use the dollar sign. Anchor it to the end of what you pass to regex. This expression returns all countries that became Poland after a laureate's birth. What you see here is all you need for the exercises. Use a caret to match the beginning of a field, a dollar sign to match the end, and a backslash to escape parentheses.